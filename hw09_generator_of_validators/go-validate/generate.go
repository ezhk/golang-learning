package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

type Term struct {
	Name     string
	Argument string
}

var SimpleGeneratorCondition *template.Template = template.Must(template.New("simple").Parse(`
		if {{.Expression}} {
			validationError = append(validationError, ValidationError{Field:"{{.Fieldname}}", Error:errors.New("{{.Error}}")})
		}
`))

var RangeGeneratorCondition *template.Template = template.Must(template.New("simple").Parse(`
	for _, val := range {{.Type}}
		if {{.Expression}} {
			validationError = append(validationError, ValidationError{Field:"{{.Fieldname}}", Error:errors.New("{{.Error}}")})
		}
`))

type SimpleGeneratorStruct struct {
	Expression string
	Fieldname  string
	Error      string
}

type RangeGeneratorStruct struct {
	SimpleGeneratorStruct
	List []string
	Type string
}

// type Field struct {
// 	Name string
// 	Type string
// 	Tag  reflect.StructTag
// }

// type ParsedStruct struct {
// 	StructName string
// 	Fields     []Field
// }

// var goValidateTemplate = template.Must(template.New("go-validate").Parse(`
// // generated by go-validate; DO NOT EDIT
// package models

// import (
// 	"fmt"
// 	"regexp"
// )

// type ValidationError struct {
// 	Field string
// 	Err   error
// }

// func ContainsInt(toFind int, searchString string) bool {
// 	for _, strValue := range strings.Split(searchString, ",") {
// 		invValue, err := strconv.Atoi(strValue)
// 		if err != nil {
// 			return false
// 		}
// 		if toFind == invValue {
// 			return true
// 		}
// 	}
// 	return false
// }

// func ContainsStr(toFind string, searchString string) bool {
// 	for _, value := range strings.Split(searchString, ",") {
// 		if toFind == value {
// 			return true
// 		}
// 	}
// 	return false
// }

// {{range $structName, $fields := .Structs}}
// func (structName $structName) Validate() ([]ValidationError, error) {
// 	errors := make([]ValidationError, 0)

// 	{{range $field}}
// 	{{if .Slice == true}}
// 	for _, value := range structName.{{.}} {
// 	{{else}}
// 	value := structName.{{.}}
// 	{{end}}

// 	{{range _, $condition := .Condution}}
// 		{{if $condition.Name == "len"}}
// 		if len(value) != {{$condition.Argument}} {
// 			errors = append(errors, ValidationError{Field: "{{.}}", Err: fmt.Errorf("invalid {{.}} length")})
// 		}
// 		{{else if $condition.Name == "min"}}
// 		if value < {{$condition.Argument}} {
// 			errors = append(errors, ValidationError{Field: "{{.}}", Err: fmt.Errorf("invalid {{.}} length")})
// 		}
// 		{{else if $condition.Name == "max"}}
// 		if value > {{$condition.Argument}} {
// 			errors = append(errors, ValidationError{Field: "{{.}}", Err: fmt.Errorf("invalid {{.}} length")})
// 		}
// 		{{else if $condition.Name == "regexp"}}
// 		if re := regexp.MustCompile("{{$condition.Argument}}"); re.FindString(value) == "" {
// 			errors = append(errors, ValidationError{Field: "{{.}}", Err: fmt.Errorf("invalid {{.}} field, empty regexp")})
// 		}
// 		{{else if {{$condition.Name}} == "in"}}
// 			{{if .Type == "int"}}
// 			if !ContainsInt(value, "{{$condition.Argument}}") {
// 				errors = append(errors, ValidationError{Field: "{{.}}", Err: fmt.Errorf("invalid {{.}} value in range")})
// 			}
// 			{{else if .Type == "string"}}
// 			if !ContainsStr(value, "{{$condition.Argument}}") {
// 				errors = append(errors, ValidationError{Field: "{{.}}", Err: fmt.Errorf("invalid {{.}} value in range")})
// 			}
// 		{{end}}
// 	{{end}}

// 	{{if .Slice == true}}
// 	}
// 	{{end}}

// return errors, nil
// {{end}}
// `))

func GeneratorField(field Field) (string, error) {
	field, err := ValidateField(field)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer

	if field.Type[:2] == "[]" {
		buf.WriteString(fmt.Sprintf(`
	for _, val := range st.%s {
`, field.Name))
	}

	conditions := strings.Split(field.Tag, "|")
	for _, cond := range conditions {
		validateCondition := strings.SplitN(cond, ":", 2)
		keyword, expression := validateCondition[0], validateCondition[1]

		switch keyword {
		case "len":
			SimpleGeneratorCondition.Execute(&buf, SimpleGeneratorStruct{
				Expression: fmt.Sprintf("len(st.%s) != %s", field.Name, expression),
				Fieldname:  field.Name,
				Error:      fmt.Sprintf("incorrect .%s len", field.Name),
			})
		case "min":
			SimpleGeneratorCondition.Execute(&buf, SimpleGeneratorStruct{
				Expression: fmt.Sprintf("st.%s < %s", field.Name, expression),
				Fieldname:  field.Name,
				Error:      fmt.Sprintf("incorrect .%s min value", field.Name),
			})
		case "max":
			SimpleGeneratorCondition.Execute(&buf, SimpleGeneratorStruct{
				Expression: fmt.Sprintf("st.%s > %s", field.Name, expression),
				Fieldname:  field.Name,
				Error:      fmt.Sprintf("incorrect .%s max value", field.Name),
			})
		case "regexp":
			SimpleGeneratorCondition.Execute(&buf, SimpleGeneratorStruct{
				Expression: fmt.Sprintf(`regexp := regexp.MustCompile("%s"); re.FindString(st.%s) == ""`, expression, field.Name),
				Fieldname:  field.Name,
				Error:      fmt.Sprintf("incorrect .%s value by regexp filtering", field.Name),
			})
		case "in":

			values := strings.Split(expression, ",")
			fmt.Println(strings.Join([]string(values), ","))
		}
	}

	if field.Type[:2] == "[]" {
		buf.WriteString(fmt.Sprintf(`
	}
`, field.Name))
	}

	return buf.String(), nil
}
