package main

import (
	"bytes"
	"go/format"
	"text/template"
)

var goValidateTemplate = template.Must(template.New("go-validate").Parse(`
// generated by go-validate; DO NOT EDIT
package models

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

type ValidationError struct {
	Field string
	Err   error
}

func ContainsInt(toFind int, searchingString string) bool {
	for _, strValue := range strings.Split(searchingString, ",") {
		invValue, err := strconv.Atoi(strValue)
		if err != nil {
			return false
		}
		if toFind == invValue {
			return true
		}
	}
	return false
}

func ContainsStr(toFind string, searchingString string) bool {
	for _, value := range strings.Split(searchingString, ",") {
		if toFind == value {
			return true
		}
	}
	return false
}

{{range $index, $struct := .}}
{{if $struct.Fields}}
func (structName {{$struct.Name}}) Validate() ([]ValidationError, error) {
	errors := make([]ValidationError, 0)

	{{range $index, $field := $struct.Fields}}

		{{/* begin loop for slices */}}
		{{$variableName := $field.Name | printf "%s.%s" "structName"}}
		{{if $field.IsSlice}}
			for _, value := range structName.{{$field.Name}} {
			{{$variableName = "value"}}			
		{{end}}

		{{range $index, $condition := $field.Conditions}}
			{{if eq $condition.Name "len"}}
				if len({{$variableName}}) != {{$condition.Value}} {
					errors = append(errors, ValidationError{Field: "{{$field.Name}}", Err: fmt.Errorf("invalid {{$field.Name}} length")})
				}
			{{else if eq $condition.Name "min"}}
				if {{$variableName}} < {{$condition.Value}} {
					errors = append(errors, ValidationError{Field: "{{$field.Name}}", Err: fmt.Errorf("invalid {{$field.Name}} length")})
				}
			{{else if eq $condition.Name "max"}}
				if {{$variableName}} > {{$condition.Value}} {
					errors = append(errors, ValidationError{Field: "{{$field.Name}}", Err: fmt.Errorf("invalid {{$field.Name}} length")})
				}
			{{else if eq $condition.Name "regexp"}}
				if re := regexp.MustCompile({{$condition.Value | printf "%q"}}); re.FindString({{$variableName}}) == "" {
					errors = append(errors, ValidationError{Field: "{{$field.Name}}", Err: fmt.Errorf("invalid {{$field.Name}} field, empty regexp")})
				}
			{{else if eq $condition.Name "in"}}
				{{if eq $field.Type "int"}}
					if !ContainsInt({{$variableName}}, "{{$condition.Value}}") {
						errors = append(errors, ValidationError{Field: "{{$field.Name}}", Err: fmt.Errorf("invalid {{$field.Name}} value in range")})
					}
				{{else if eq $field.Type "string"}}
					if !ContainsStr({{$variableName}}, "{{$condition.Value}}") {
						errors = append(errors, ValidationError{Field: "{{$field.Name}}", Err: fmt.Errorf("invalid {{$field.Name}} value in range")})
					}
				{{end}}
			{{end}}
		{{end}}

		{{/* end loop for slices */}}
		{{if $field.IsSlice}}
			}
		{{end}}
	{{end}}
	return errors, nil
}
{{end}}
{{end}}
`))

func GenerateDocument(recvStruct []ParsedStruct) ([]byte, error) {
	var buf bytes.Buffer
	err := goValidateTemplate.Execute(&buf, recvStruct)
	if err != nil {
		return nil, err
	}

	document, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}

	return document, nil
}
