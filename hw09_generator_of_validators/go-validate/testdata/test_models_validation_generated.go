// generated by go-validate; DO NOT EDIT
package models

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

type ValidationError struct {
	Field string
	Err   error
}

func ContainsInt(toFind int, searchingString string) bool {
	for _, strValue := range strings.Split(searchingString, ",") {
		invValue, err := strconv.Atoi(strValue)
		if err != nil {
			return false
		}
		if toFind == invValue {
			return true
		}
	}
	return false
}

func ContainsStr(toFind string, searchingString string) bool {
	for _, value := range strings.Split(searchingString, ",") {
		if toFind == value {
			return true
		}
	}
	return false
}

func (structName User) Validate() ([]ValidationError, error) {
	errors := make([]ValidationError, 0)

	if len(structName.ID) != 36 {
		errors = append(errors, ValidationError{Field: "ID", Err: fmt.Errorf("invalid ID length")})
	}

	if structName.Age < 18 {
		errors = append(errors, ValidationError{Field: "Age", Err: fmt.Errorf("invalid Age length")})
	}

	if structName.Age > 50 {
		errors = append(errors, ValidationError{Field: "Age", Err: fmt.Errorf("invalid Age length")})
	}

	if re := regexp.MustCompile("^\\w+@\\w+\\.\\w+$"); re.FindString(structName.Email) == "" {
		errors = append(errors, ValidationError{Field: "Email", Err: fmt.Errorf("invalid Email field, empty regexp")})
	}

	for _, value := range structName.Phones {

		if len(value) != 11 {
			errors = append(errors, ValidationError{Field: "Phones", Err: fmt.Errorf("invalid Phones length")})
		}

	}

	return errors, nil
}

func (structName App) Validate() ([]ValidationError, error) {
	errors := make([]ValidationError, 0)

	if len(structName.Version) != 5 {
		errors = append(errors, ValidationError{Field: "Version", Err: fmt.Errorf("invalid Version length")})
	}

	return errors, nil
}
